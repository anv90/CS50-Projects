# D&D Damage Calculator
#### Video Demo:  https://youtu.be/onkpNCfB8ow
#### Description:
I created a D&D Damage Calculator. It is meant to be useful for dungeon masters to calculate damage and randomize attacks. It can also help to keep track of mobs. The classes file contains all the different classes to build monsters and players. Because there is a parent class that controls the hit points (hp) setter and getter, as well as initializes many instance attributes, it is easier to add more monsters as the project expands. The Mob parent class includes the boolean is_alive, name, and hp attributes in the init method. It also has methods for str and a default attack method that can work for any monster. This attack method assumes that armor class has been met for an attack, because it is more generalizable for all monsters or player types. The hp setter checks how much health a mob has before setting it. If it is below zero, the setter prints that someone has been slain, and changes the boolean is_alive to False.

The Player class inherits Mob. It has its own class method in order to create new player objects. This is so that dungeon masters don’t have to keep track of players hp and armor class, because the system will do it for them. The get method asks players for armor class, hp, and name to initialize player objects. It uses regex to check for bad input and send back a Value Error.

The Bandit and Owlbear class inherit Mob. Both classes overload the attack method in order to have their specific attacks that cause different amounts of damage. In order to roll for hit (to see if a monster was able to attack a player, or failed to meet their armor class), I used the random module to simulate a 20 sided dice. I looked for a pip installable library that had D&D dice, however, I did not find any that I liked, so I decided to stick with the random module.Each monster may have multiple types of attacks and they use different dice to roll for variable damage, however, I decided not to include the randomizing attack type and damage because of time constraints and program complexity. The Bandit and Owlbear classes also have a default name value of the mob, which is just the name of the mob. This can be overridden in future implementations if there is a boss battle the players are fighting or if there is a bandit or owlbear who functions more as a plot important non-player character.

The project file contains the main function and four other functions. The main function contains argparse in order to initialize the numbers in the mob the players are fighting. Once arg parse collects arguments, it matches the arguments to cases in order to initialize enemies(such as bandits or owlbears) for the players to fight. The enemies are then added a list, which is passed as a parameter to the battle simulator function. In the call to battle simulator is a call to the generate player function. This function uses the Player.get function, but has a try, except framework that handles a value error from bad user input by giving help messages and prompting again. Once a player is created, they are appended to a player list. When a user causes an EOF Error, the program will stop prompting for input. The completed player list gets sent to the battle simulator. The lists were used in order to keep player and enemy objects organized so that the battle simulator will know which objects to act on.

The battle simulator first cycles through the enemy list and has each enemy randomly attack a player. Using print, it displays which player got attacked and how many hit points they have remaining. It then cycles through the player list and has each player choose which enemy to attack and how much damage they dealt, by way of the inherited attack method. This cycle continues until all enemies die (reduced to zero hit points) or a player is reduced to zero hit points, in which case the death saves function is called.

The death saves function prompts the user for a death save roll from 1 to 20, guarding against rolls that wouldn’t be possible with a 20 sided dice. Once three rolls are made, it returns how many rolls above ten that the user inputted. The save outcome function uses the value from the death saves function to determine whether or not a character survived. If the returned value was more than or equal to 2 (meaning that the user rolled at least two rolls above 10), the player survives.
If the player survives, the program prompts the user as to how many hit points to heal the player, and also changes the boolean is_alive to True. If the player does not survive, it displays a message that the player is dead and then the battle simulator function resumes. The dead player is taken out of the player list, and the battle simulator continues until all enemies are dead, only interrupted if another player is reduced to 0 hit points.

The test file tests the functions death saves, generate player, and save outcome. A test player is used for all tests. The death saves test uses monkeypatch to patch the input function for rolls, along with a list iterator to check different values for rolls. The generate player and save outcome tests utilize the mock class, mock objects, and side effects in order to test the functions without having to prompt the user for input.
